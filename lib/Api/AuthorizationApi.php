<?php
/**
 * AuthorizationApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * BTCPay Greenfield API
 *
 * A full API to use your BTCPay Server
 *
 * OpenAPI spec version: v1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.23
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * AuthorizationApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AuthorizationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiKeysAuthorizeGet
     *
     * Authorize User
     *
     * @param  string[] $permissions The permissions to request. (See API Key authentication) (optional)
     * @param  string $application_name The name of your application (optional)
     * @param  bool $strict If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting. (optional, default to true)
     * @param  bool $selective_stores If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control. (optional, default to false)
     * @param  string $redirect The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list. (optional)
     * @param  string $application_identifier If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function apiKeysAuthorizeGet($permissions = null, $application_name = null, $strict = 'true', $selective_stores = 'false', $redirect = null, $application_identifier = null)
    {
        $this->apiKeysAuthorizeGetWithHttpInfo($permissions, $application_name, $strict, $selective_stores, $redirect, $application_identifier);
    }

    /**
     * Operation apiKeysAuthorizeGetWithHttpInfo
     *
     * Authorize User
     *
     * @param  string[] $permissions The permissions to request. (See API Key authentication) (optional)
     * @param  string $application_name The name of your application (optional)
     * @param  bool $strict If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting. (optional, default to true)
     * @param  bool $selective_stores If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control. (optional, default to false)
     * @param  string $redirect The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list. (optional)
     * @param  string $application_identifier If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiKeysAuthorizeGetWithHttpInfo($permissions = null, $application_name = null, $strict = 'true', $selective_stores = 'false', $redirect = null, $application_identifier = null)
    {
        $returnType = '';
        $request = $this->apiKeysAuthorizeGetRequest($permissions, $application_name, $strict, $selective_stores, $redirect, $application_identifier);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation apiKeysAuthorizeGetAsync
     *
     * Authorize User
     *
     * @param  string[] $permissions The permissions to request. (See API Key authentication) (optional)
     * @param  string $application_name The name of your application (optional)
     * @param  bool $strict If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting. (optional, default to true)
     * @param  bool $selective_stores If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control. (optional, default to false)
     * @param  string $redirect The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list. (optional)
     * @param  string $application_identifier If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiKeysAuthorizeGetAsync($permissions = null, $application_name = null, $strict = 'true', $selective_stores = 'false', $redirect = null, $application_identifier = null)
    {
        return $this->apiKeysAuthorizeGetAsyncWithHttpInfo($permissions, $application_name, $strict, $selective_stores, $redirect, $application_identifier)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiKeysAuthorizeGetAsyncWithHttpInfo
     *
     * Authorize User
     *
     * @param  string[] $permissions The permissions to request. (See API Key authentication) (optional)
     * @param  string $application_name The name of your application (optional)
     * @param  bool $strict If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting. (optional, default to true)
     * @param  bool $selective_stores If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control. (optional, default to false)
     * @param  string $redirect The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list. (optional)
     * @param  string $application_identifier If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiKeysAuthorizeGetAsyncWithHttpInfo($permissions = null, $application_name = null, $strict = 'true', $selective_stores = 'false', $redirect = null, $application_identifier = null)
    {
        $returnType = '';
        $request = $this->apiKeysAuthorizeGetRequest($permissions, $application_name, $strict, $selective_stores, $redirect, $application_identifier);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiKeysAuthorizeGet'
     *
     * @param  string[] $permissions The permissions to request. (See API Key authentication) (optional)
     * @param  string $application_name The name of your application (optional)
     * @param  bool $strict If permissions are specified, and strict is set to false, it will allow the user to reject some of permissions the application is requesting. (optional, default to true)
     * @param  bool $selective_stores If the application is requesting the CanModifyStoreSettings permission and selectiveStores is set to true, this allows the user to only grant permissions to selected stores under the user&#x27;s control. (optional, default to false)
     * @param  string $redirect The url to redirect to after the user consents, with the query parameters appended to it: permissions, user-id, api-key. If not specified, user is redirected to their API Key list. (optional)
     * @param  string $application_identifier If specified, BTCPay Server will check if there is an existing API key associated with the user that also has this application identifier, redirect host AND the permissions required match(takes selectiveStores and strict into account). &#x60;applicationIdentifier&#x60; is ignored if redirect is not specified. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiKeysAuthorizeGetRequest($permissions = null, $application_name = null, $strict = 'true', $selective_stores = 'false', $redirect = null, $application_identifier = null)
    {

        $resourcePath = '/api-keys/authorize';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($permissions)) {
            $permissions = ObjectSerializer::serializeCollection($permissions, 'multi', true);
        }
        if ($permissions !== null) {
            $queryParams['permissions'] = ObjectSerializer::toQueryValue($permissions, null);
        }
        // query params
        if ($application_name !== null) {
            $queryParams['applicationName'] = ObjectSerializer::toQueryValue($application_name, null);
        }
        // query params
        if ($strict !== null) {
            $queryParams['strict'] = ObjectSerializer::toQueryValue($strict, null);
        }
        // query params
        if ($selective_stores !== null) {
            $queryParams['selectiveStores'] = ObjectSerializer::toQueryValue($selective_stores, null);
        }
        // query params
        if ($redirect !== null) {
            $queryParams['redirect'] = ObjectSerializer::toQueryValue($redirect, 'url');
        }
        // query params
        if ($application_identifier !== null) {
            $queryParams['applicationIdentifier'] = ObjectSerializer::toQueryValue($application_identifier, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/html']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/html'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
